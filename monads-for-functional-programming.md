---
authors: "Philip Wadler"
title: "Monads for functional programming"
date: "1993"
license: "CC BY-NC-SA 3.0"
link: "[homepages.inf.ed.ac.uk](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)"
---

# 함수형 프로그래밍을 위한 모나드 (작성중)

## 초록

이 논문은 모나드(monad) 를 사용하여 함수형 프로그램을 구조화하는 방법을 설명한다. 모나드는 다른 언어들에서 발견되는 전역 상태, 예외 처리, 출력 또는 비결정성 등의 이른바 효과(effect) (note. 여기서 의 효과는 이른바 부수효과-side effect 를 일컫는 것으로 보아도 무방할 것 같다.) 를 순수 함수형 언어에서 시뮬레이션하기에 적합한 프레임워크를 제공한다. 이 논문에서는, 세 가지 케이스를 통해 자세히 살펴보고자 한다. 1) 모나드가 간단한 평가자 (evaluator) 프로그램을 수정하는데 어떻게 도움이 되는지, 2) 리스트 형태의 데이터를 in-place 업데이트에 어떻게 사용되는지, 3) 모나드를 사용하여 어떻게 parser 를 만드는지.

## 1. 서론

"저는 순수할까요, 아니면 순수하지 않을까요?"
함수형 프로그래밍 커뮤니티는 두 가지로 나뉜다. Marinda0 와 Haksell 는 순수하며, 간단한 람다 계산을 기반으로 한 순수 언어이다. Scheme 과 Standard ML 은 비순수 언어로 할당, 예외 또는 계속 진행이라는 수 많은 효과를 이용하여 좀 더 강화된 람다 계산을 제공한다. 순수 언어는 프로그래밍의 목적과 이유를 쉽게 파악할 수 있고, Lazy Evaluation 측면 에서 이득을 볼 수 있지만, 비 순수 언어는 수행 효율성의 이점을 제공하며 때때로 더 간결한한 표현을 가능하게 한다.

개념적 컴퓨터 과학의 최근 발전중 특히 타입 이론과 카테고리 이론 분야에서의 발전이, 순수 언어와 비순수 언어의 이점을 통합하는 새로운 접근법을 제안하고 있다. 이 논문에서는 비순수한 사이드 이펙트를 순수 함수적 언어로 통합하기 위해 모나드를 사용하는 방법을 설명할 것이다.

모나드는 카테고리 이론에서 나오는 개념으로, 모기(Moggi)가 프로그래밍 언어의 방식으로 의미론을 구조화하는 데 적용하였으며[13,14], 동일한 방법을 함수적 프로그램의 구조화에도 적용할 수 있다[21,23].

모나드가 어떻게 응용될 수 있는지, 세 가지 사례 연구로 설명하고자 한다. 2장에서는 모나드를 사용하여 간단한 평가자(주. 평가자 Evaluator: 프로그래밍 언어를 컴파일 하는 과정에서 syntax tree 구조로부터 값과 행동을 생산해내는 평가-evaluation 이라고 하며 평가자은 이러한 작업을 수행하는 프로그램일 일컫는다.) 를 구조화하여 수정하기 쉽게하는 방법을 보여준다. 3장에서는 모나드가 되기 위한 충분법칙을 설명한다. 4장에서는 순수 함수언어에서의 고질적인 문제인 updatable state 에 대한 모나드를 이용한 새로운 해결책을 제시한다. 5장에서는 모나드를 파서를 만드는 문제에 재귀적으로 적용하는 것을 다룬다; 이는 그 자체로도 흥미로운 내용이지만, 이를 통해 sequencing 과 alternation 이라는 프로그래밍의 중요한 두가지 개념을 바라보는 새로운 패러다임을 제시한다.

이 논문에서 제시하는 구조화 방법들은, 카테고리 이론으로부터 얻어낸 통찰력 없이는 발견될 수 없는 것들이다. 하지만, 이미 발견된 방법들은 카테고리 이론 없이도 쉽게 표현하고 설명될 수 있는 것들이다. 따라서, 이 논문을 읽기 위해 카테고리 이론에 대한 사전 지식은 필요하지 않다.

이 논문의 예제들은 Haskell로 작성되었지만, 특별한 배경지식은 필요 없다. 필요한 것은 순수, 비순수 함수형 프로그래밍의 기초에 대한 일반적인 사전지식이다. 이에 대한 내용은 [3,12] 를 참조하면 좋다. 앞으로 논문에서 언급될 언어들은 Haskell [4], Miranda [20], Standard ML [11] 그리고 Scheme [17]이다.

## 2. 모나드를 사용하여 평가자 (evaluator) 만들기

함수형 언어는 모든 데이터 흐름이 명시적으로(explicit) 드러나는 장점이 있다. 하지만 때로는 바로 이 점이 단점이 되기도 한다.

함수형 언어에서 프로그램은 식들의 집합으로 작성된다. 또한, 명시적인 데이터 흐름은 free variable (주. free 를 out of scope 라고 생각하면 좋을 것 같다; 함수안에서 scope 에서 정의되지 않은 변수를 의미한다.) 들에만 의존하여 결과 값을 계산된다는 것을 보장한다. 따라서 동등한 요소들을 교체하는 행위가 항상 유효하다. 이러한 점들은 함수형 프로그램을 쉽게 파악할 수 있게 한다. 또한 명시적 데이터 흐름은 계산의 순서가 상관없이 동등한 결과 값을 보장함으로, 지연 평가 (lazy evalutation) 가 가능해진다.

이런 명시적인 데이터 흐름은 모듈화(modularity)에 대한 장단점을 모두 갖추고 있다. 데이터가 들어오고 나가는 것이 명확하고 접근가능하므로, 이런 큰 유연성 때문에 궁극의 모듈성을 갖추고 있다고 라고 말할 수 있지만, 한편으로는 알고리즘의 본질이 데이터를 생성하는 지점에서 데이터를 사용하는 지점까지 이어진 plumbing 아래에 감춰져 있을 수 있기 때문에 최약의 모듈성을 갖추고 있다고 할 수 도 있다.

평가자 프로그램을 순수 함수형 언어로 작성한다고 해보자.

- 함수의 오류 처리를 구현하기 위해서는, 오류를 확인하고 적절하게 처리하도록 함수 각각의 재귀적 호출(recursive call) 부분을 수정해야 한다. 만약 예외(exception)를 가지는 비순수 언어라면 이런 변경 작업은 필요 없다.
- 함수에서 발생한 연산 횟수를 세기 위해서는, 각각의 재귀 호출에서 적절하게 카운트를 전달해야 한다. 만약 전역 변수를 가진 비순수 언어를 사용한다면, 전역 변수의 카운트만을 증가시키면 되기 때문에, 이런 변경 작업은 필요 없다.
- 함수에서 발생한 호출들을 트레이싱(tracing) 하려면, 적절한 트레이싱 데이터를 전달하도록 각 재귀 호출을 수정해야 한다. side effect로 출력을 동작할 수 있는 비순수 언어를 사용했다면 이러한 변경 작업은 필요 없다.

그러나, 모나드를 사용하여 위의 내용들을 구현할 수 도 있다.
아래 내용들은 모나드를 사용하여 평가자을 작성하는 방법들이다. 모나드를 이용하면, 위에서 언급한 순수함수 언어의 변경 방법 대신에, 모나드를 재정의하고 일부 지역적인 변경만을 수행하면 된다.

이러한 프로그래밍 스타일을 통해 비순수 언어의 다양한 기능으로 제공하는 유연성의 일부를 순수 언어에 제공할 수 있다. 명시적 데이터에서 제공되는 유연성과 암시적으로 숨겨진 plumbing 으로 발생하는 간결함 사이의 긴장을 완전히 없앨 수는 없지만, 개선은 가능하다.

아래에서는 간단한 용어들을 다루는 기초적인 평가자 프로그램을 만드는 것으로 시작하여, 예외, 상태 및 출력을 모사할 수 있는 변경 작업들을 진행한다. 이 과정에서 이 작업들의 공통점을 분석하고, 이들로부터 모나드의 개념을 추출해 볼 것이다. 그 다음 각각의 변경 작업들이 모나드 라는 프레임워크에 어떻게 잘 들어맞는지를 살펴볼 것이다.

### 2.1 0번째 변형: 간단한 평가자

이 변경작업에서는 굉장히 단순한 Term 을 다루는 평가자프로그램을 다룰 것이다. (주. Term 은 아래와 같이 새롭게 정의한 약속어, 타입 이다.)

```
data Term = Con Int | Div Term Term
```

Term 은 상수 Con a (a 는 정수) 또는 t 와 u 라는 또다른 Term 들로 이루어진 분수 Div t u 중 하나이다. (주. t 와 u 가 또다른 Term 이기 때문에, 재귀적으로 나누기를 수행하는 타입이라고 생각하면 될 것이다.)

이 Term 을 다루는 평가자는 아래와 같이 매우 간단하다.

```
eval :: Term -> Int
eval(Con a) = a
eval(Div t u) = eval t ÷ eval u
```

eval 함수는 Term 을 정수로 변환한다. Term 이 상수이면 상수를 반환하고, Term 이 분수 (Div t u) 이면 재귀적으로 하위 Term 이 평가되고 결과 값끼리의 분수가 계산된다. 정수 나눗셈을 표현하기 위해 '÷'를 사용했다.

아래는 Term 의 예시입니다.

```
answer,error :: Term
answer = (Div (Div (Con 1972 ) (Con 2 )) (Con 23 ))
error = (Div (Con 1)(Con 0))
```

첫번째 eval 함수의 결과인 answer 는 ((1972 ÷ 2 ) ÷ 23 ))의 값인 42다. 기본 평가자는 오류 처리를 포함하지 않으므로 두번째 eval 함수의 값 error 의 결과는 undefined 이다.

### 2.2 1번째 변형: 예외처리

오류 처리를 추가하고자 한다면, 위의 두 번째 예제에서 옳은 오류 메시지를 반환하도록 할 수 있다. 비순수 언어에서는 예외(exception)를 사용하여 이를 쉽게 이를 수행할 수 있다.

순수 언어로 예외 처리를 모방하기 위해서는 예외를 발생시킬 수 있는 연산을 나타내는 타입을 만들어야 한다.

```
data M a = Raise Exception | Return a
type Exception = String
```

타입 M a 의 값은 Raise e 이거나 Return a 의 형식이다. e는 예외이고, a는 타입 a의 값이다. 관례상, a는 M a와 같이 타입 변수로도, Return a와 같이 그 타입의 값을 의미하는 변수로도 사용된다.
('데이터 Data'와 '타입 Type' 선언의 차이점에 대해 한마디 하자면. '데이터' 선언은 위 경우의 M과 같은 새로운 데이터 유형을 소개하거나, 위 경우의 Raise 와 Return 같이 해당 타입의 값에 대한 새로운 생성자를 소개하는 것이다. '타입' 선언은 위의 Exception 이 String 의 다른 이름인 것처럼, 기존에 존재하는 타입에 대한 새로운 이름을 소개하는 것이다.)
평가자에 이러한 표현을 적용하는 것은 직관적이기는 하지만 지루한 일이다.

```
eval :: Term -> M Int
eval(Con a) = Return a
eval(Div t u) = case eval t of
  Raise e -> Raise e
  Return a ->
    case eval u of
      Raise e -> Raise e
      Return b ->
        if b = 0
          then Raise "divide by zero"
          else Return (a ÷ b)
```

평가자의 각 호출에서 결과의 형식을 점검해야 한다. 예외가 발생하면 예외를 다시 제기하고, 값이 반환되면 계속 진행한다. answer에 새 평가자를 적용하면 (Return 42)이 반환되고, error에 적용하면 (Raise "divide by zero")이 반환된다.

### 2.3 2번째 번형: 상태

이번엔 평가자 수행 과정중에 나누기 연산의 발생 횟수를 세려고 한다. 비순수 언어에서는 전역 상태를 사용하여 쉽게 이를 수행할 수 있다. 주어진 변수를 초기 값을 0으로 설정하고, 하나의 나누기 연산이 일어날 때마다 1씩 증가시키면 된다.
순수 언어에서는 상태값에 작용하는 연산을 표현하는 타입을 정의해, 전역 상태 동작을 모방할 수 있다.

```
type M a = State -> (a,State)
type State = Int
```

이제 타입 M의 값 a는 초기 상태를 받아, 최종 상태와 연산 결과의 쌍을 반환하는 함수이다.
다시 한번 평가자에 이를 적용하는 것은 간단하지만 지루한 작업이다.

```
eval :: Term -> M Int
eval(Con a) x = (a, x)
eval(Div t u) x =let (a,y) = eval t x in
  let (b, z) = eval u y in (a ÷ b, z + 1)
```

평가자가 호출될 때마다, 이전의 상태 값이 전달되고, 결과로부터 추출된 새로운 상태 값이 알맞게 반환된다.
평가자에 answer 와 0 를 입력하면 (42,2) 가 반환된다. 즉 0 이 상태의 초기 값으로 주어졌을때 answer 는 42 이고, 최종 상태값은 2 이며, 이는 2번의 나누기가 수행되었다는 것을 의미한다.

### 2.4 3번째 변형: 아웃풋

마지막으로 실행내용을 트레이싱하고 이를 표시하고자 한다. 비순수 언어에서는 알맞은 위치에 출력 명령을 삽입함으로써 쉽게 할 수 있는 일이다.
순수 언어에서는 출력을 모방하기 위해 출력을 생성하는 계산을 나타내는 타입을 정의할 수 있다.

```
type M a =(Output, a)
type Output = String
```

이제 M a 타입의 값은 생성된 출력과 계산된 반환값의 쌍이다.
또 한 번, 이 내용을 적용하는 것은 직관적이지만 지루한 일이다.

```
eval :: Term -> M Int
eval(Con a) = (line(Con a) a, a)
eval(Div t u) = let (x, a) = eval t in
  let (y, b) = eval u in
    (x ++ y ++ line(Div t u) (a ÷ b), a ÷ b)
line :: Term -> Int -> Output
line t a = "eval (" ++ showterm t ++ ") <= " + showint a ++ "\n"
```

평가자의 각 호출에서 발생한 출력이 수집되어 상위 호출의 출력을 이루게 된다. 함수 line 은 한 줄의 출력을 생성한다. 여기서 showterm과 showint는 용어와 정수를 문자열로 변환하고, ++ 는 문자열을 이어 붙이고, "\n"는 줄바꿈을 포함하는 문자열이다. (주. 원문에서는 ↵ 이었지만 \n 으로 대체하였다.)
eval answer 는 (x, 42) 라는 쌍을 반환하고 여기에서 x 는 아래와 같은 연산이 어떻게 이루어졌는지를 표현하는 문자열이며, 그 결과는 아래와 같다.

```
eval (Con 1972 ) <= 1972
eval (Con 2 ) <= 2
eval (Div (Con 1972 ) (Con 2 )) <= 986
eval (Con 23 ) <= 23
eval (Div (Div (Con 1972 ) (Con 2 )) (Con 23 ))) <= 42
```

현재까지의 논의된 바를 살펴보자면, 비순수 언어로 작성된 프로그램이 순수 언어 프로그램보다 더 쉽게 위의 내용들을 구현할 수 있는 것 간다. 하지만 때때로 반대의 경우도 있다. 만약, 위의 프로그램에서 실행 트레이스를 아래와 같이 역순으로 표시하도록 수정해보도록 하자.

eval (Div (Div (Con 1972 ) (Con 2 )) (Con 23 ))) ⇐ 42 eval (Con 23 ) ⇐ 23
eval (Div (Con 1972 ) (Con 2 )) ⇐ 986
eval (Con 2 ) ⇐ 2
eval (Con 1972 ) ⇐ 1972

이 작업은 순수언어를 사용하면 굉장히 쉽게 이루어 질 수 있는데,

```
x ++ y ++ line(Div t u) (a ÷ b)
```

의 라인을 아래와 같이 바꾸기만 하면 된다.

```
line(Div t u) (a ÷ b) ++  x ++ y
```

하지만 변경을 비순수 언어로 구현하는 것은 쉬운 일이 아니다. 비순수 언어에서 출력은 계산의 사이드이펙트로 발생하는데, 문제는 이제 연산이 아직 계산되기도 전에 해당 연산에 대한 출력물을 만들어 내고 보여줘야 한다는 점이다. 물론 비순수 언어에서도 이를 해결할 수 있는 여러 방법들이 있다. 하지만, 모두 상당한 량의 변경작업을 필요로 한다.

### 2.5 monad 를 사용한 평가자

위에서 살펴본 인터프리터의 변형들은 모두 비슷한 구조를 가지고 있고, 이 공통점으로부터 모나드라는 추상적 개념을 도출해 볼 수 있다.
각각의 구현작업들에서 우리는 하나의 연산 타입 M을 소개하였는데, 각각의 경우에서 M 은 예외를 제기할 수 있었고, 상태에 작용할 수 있었고, 출력을 생성할 수 있었다. 이제 독자들은 M 이 monad 의 약자 였다는 것을 추측해볼 수 있을 것이다.

평가자의 원래 타입은 Term -> Int 이지만, 각 변형에서는 Term -> M Int 형태로 표현되었다. 일반적으로 모나드를 이용할때, a -> b 타입의 함수를 a -> M b 타입의 함수로 대체할 수 있다. 이는 a 타입의 인수를 받아서 b 타입의 결과를 반환하는 함수이지만, 추가적으로 가능한 효과를 M으로 표현한 것입니다. 이 효과로는 상태를 조작하거나 출력을 생성하거나 예외를 발생시키는 것이 있다.

M 타입을 정의하는데, 어떤 종류의 연산들이 필요할까? 예제를 살펴보면 두 가지 종류의 연산을 찾을 수 있다. 첫 번째 방법은 unit 으로 해당 값 반환하고 아무런 작업도 수행하지 않는 연산이다. 아래와 같이 unit 이라는 타입을 정의할 수 있다.

```
unit :: a -> M a
```

두번째는 \* 로 a -> M b 타입의 함수를 M a 타입의 연산에 적용하는(applicate) 연산이며, 아래와 같이 정의할 수 있다. 이 경우는 인수가 함수보다 앞에 오도록 작성하는 것이 편리하다.

```
(*) :: M a -> (a -> M b) -> M b
```

모나드는 타입 생성자 M, 그리고 unit, (\*) 라는 다형성(polymorphic) 타입의 연산이라는 3가지 요소로 이루어진다. 이 연산들은 3장에서 살펴볼 3가지 법칙을 반드시 충족하여야 한다.

우리는 위의 연산을 종종 아래와 같은 식으로 표시할 것이다.

```
m * λa.n
```

여기에서 m 과 n 은 표현식이고, a 는 변수이다. 식 λa.n 는 람다 함수이다. a 는 식 n 의 범위안에 갇혀있는 변수이다.

위의 식은 다음과 같이 읽힐 수 있다. 연산 m을 수행하고, 결과 값에 a를 바인딩한 다음, 연산 n을 수행한다. 타입은 이를 이해하는데, 유용한 가이드를 제공한다. 위에서 정의된 타입 \* 으로부터 볼 수 있듯이, 연산 m 은 M a 타입 이고, 변수 a 는 타입 a 이며, 식 n 은 타입 a -> M b 이며, 전체 식은 M b 타입에 해당합니다.

다음식도 위의 내용과 같은 의미를 지닌다.

```
let a = m in n.
```

비순수 언어에서도 동일하게 읽힌다. 연산 m을 수행하고, 결과 값을 a 에 바인딩한 다음, 연산 n을 수행하고 그 값을 반환한다. 여기서 타입은 값과 연산을 구별하는 데에는 아무런 도움이 되지 않는다. 표현식 m 은 타입 a를 가지고, 변수 a는 타입 a를 가지고, 표현식 n은 타입 b를 가지고, 전체 표현식은 타입 b를 가진다. let 이라는 표현은 (\*) 에 입력되는 인수 들의 순서를 어떻게 선택했는지를 설명해 준다. 인수 m 이 함수 λa.n 이전에 나타나는 것이 내용을 파악하기에는 좀 더 용이한 방식이다. 연산 m 이 연산 n 보다 이전에 수행되기 때문이다.

평가자를 이러한 추상화를 이용해 쉽게 재작성해 볼 수 있다.

```
eval :: Term -> M Int
eval(Con a) =unit a
eval(Div t u) = eval t * λa. eval u * λb. unit (a ÷ b)
```

우선 한마디 하자면, 람다 추상화가 가장 약하게 묶이고, 이의 응용 부분이 가장 강하게 묶이므로, 마지막 방정식은 다음과 같이 표현할 수 있다.

```
eval (Div t u) = ((eval t) * (λa. ((eval u) * (λb. (unit (a ÷ b))))))
```

타입 Term -> M Int는 평가자가 항목을 취하고 정수를 생성하는 계산을 수행한다는 것을 의미한다. (Con a) 의 연산은, 그저 a를 반환하기만 하면 된다. (Div t u)를 계산하려면, 먼저 t를 계산하고, 결과에 a를 바인딩한 다음, u를 계산하고, 결과에 b를 바인딩한 다음, a ÷ b 라는 식의 결과 값을 반환하면 된다.

새로운 평가자는 원래 기본 평가자보다 좀 더 복잡하지만, 훨씬 유연하다. 위에서 제시한 예외, 상태, 출력을 위한 변경작업들이 M, unit, \*의 정의를 수정하거나, 단지 한 두개의 지역적인 수정만 을 통해 이루어질 수 있다. 특히, 이러한 변경을 위해 평가자 eval 전체를 재작성할 필요가 없어진다.

### 2.6 0번째 변형 다시 살펴보기: 기본 평가자

가장 간단한 모나드에서는 연산이 변수 그 자체이다.

```
type M a = a
unit :: a -> I a
unit a = a
(*) :: M a -> (a -> M b) -> M b
a * k = k a
```

이는 항등 (identity) 모나드로 불린다. M 은 타임들에 대한 항등 함수이고 unit 은 항등 함수이다. 그리고 \* 은 단지 이를 적용하는 부분이다.
2.5 장의 모나드 평가자에서 정의한 M, unit 와 \* 를 위와 같이 작성해 간단히 2.1장의 기본 평가자를 구현할 수 있다.

### 2.7 1번째 변형 다시 살펴보기: 예외처리

예외처리 모나드에서는 연산이 예외를 제기(raise)하거나 혹은 값을 반환할 수 있다.

```
data M a = Raise Exception | Return a
type Exception = String
unit :: a -> M a
unit a  = Return a
(*) :: M a -> (a -> M b) -> M b
m * k = case m of
  Raise e -> Raise e
  Return a -> k a
raise :: Exception -> M a
raise e = Raise e
```

함수 unit a는 값 a 를 그대로 반환한다. 함수 m \* k는 계산 m의 결과를 살핀 후, 만약 예외라면 예외를 제기하고, 그렇지 않으면 반환한 값에 함수 k 를 적용합니다. 항등 모나드에서 \* 가 함수 적용 부분 이었던 것처럼, 예외처리 모나드의 \*는 좀 더 구체적인 함수 적용의 형태를 살펴볼 수 있다. 마지막으로 함수 raise e는 예외 e를 제기하도록 작성한다.

2.5장의 모나드 평가자에 오류 처리를 추가하고 싶으면, `unit (a ÷ b)` 부분을 아래 처럼 변경하면 된다.

```
if b = 0
  then raise “divide by zero”
  else unit (a ÷ b)
```

이것은 비순수 언어에서 예외처리를 위해 필요한 변화와 일치하는 것이다.
예상하듯이, 이 평가자는 2.2 장의 예외처리를 하는 평가자와 동일하다. 특히 이번 장에서 등장했던 \*와 unit 의 정의들을 펼치고 단순화하는 작업을 수행하면 2.2장의 평가자와 동일한 프로그램이 된다.

### 2.8 2번째 변형 다시 살펴보기: 상태

상태 모나드에서의 연산은 초기 상태를 받아서, 결과 값을 최종 상태와 한 쌍으로 반환하는 연산을 수행한다.

```
type M a = State -> (a, State)
type State = Int
unit :: a -> M a
unit a = λx.(a, x)
(*) :: M a -> (a -> M b) -> M b
m * k = λx. let (a, y) = m x in
  let (b, z)= k a y in
  (b, z)
tick :: M ()
tick = λx.((),x+1)
```

함수 unit a 의 호출은 초기 상태 x 를 받아서 값 a 와 최종 상태 x 를 반환하는 연산 자체를 반환한다. 즉, 이 연산은 상태는 변경하지 않고 a 만을 반환한다. m \* k 를 호출하면, 초기 상태 x 에서 연산 m 을 수행하여 값 a 와 중간 상태 y 를 생성한 다음, 상태 y 가 주어진 상태에서 연산 k a 를 수행하여 값 b와 최종 상태 z를 생성한다. tick 의 호출은 상태 값을 증가시키고, 빈 결과 값 () 을 반환합니다. 이 값의 타입 또한 () 로 표시됩니다.

비순수 언어에서는 tick과 같은 작업은 () -> () 타입의 함수로 표현됩니다. 가짜 인수 ()는 함수가 적용될 때까지 효과를 지연시키기 위해 필요하며, 출력 타입이 () 이므로 함수의 목적이 사이드이펙트에 있음을 추측할 수 있다. 반면에 위에서 사용된 tick 은 타입 M () 을 갖는데, 가짜 인수가 필요하지 않으며, M 을 명시하여 어떤 종류의 효과가 발생할 수 있음을 명확하게 표시한다.

모나드 평가자에 연산 횟수를 카운트하기 위해서, 2.7의 마지막 변경작업처럼 `unit (a ÷ b)` 를 아래와 같이 바꾸면 된다.

```
tick * λ(). unit (a ÷ b)
```

(여기에서 타입이 () 인 하나의 연산 e에서는 등장하지 않았던 새로운 변수 x 를 정의하여, λ\_.e 를 λx. e로 대체할 수 있다. 이는 람다 함수안의 스코프에 갇혀 있는 값이 반드시 ()여야 된다는 것을 의미한다.) 위의 tick 을 추가하는 변경 작업은 또 한번, 비순수 언어에서 수행할 변경 작업과 일치하며, 위의 식을 간단히 하는 과정만을 거치면, 2.3 절의 상태 평가자와 동일해 진다.

### 2.9 3번째 변형 다시 살펴보기: 출력

출력 모나드에서의 연산은 결과 값과 출력의 쌍을 반환한다.

```
type M a = (Output, a)
type Output = String
unit :: a → M a
unit a = ("", a)
(*) :: M a → (a → M b) → M b
m * k = let (x, a) = m in
  let (y, b) = k a in
  (x ++ y, b)
out :: Output → M ()
out x = (x , ())
```

unit a 를 호출하는 것은 값 a와 비어있는 출력 쌍을 반환한다. m \* k 를 호출하는 것은 계산 m 으로부터 출력 x와 값 a를 추출하고, 계산 k a에서 출력 y와 값 b를 추출하여 x와 y를 이어 붙인 출력과 값 b를 쌍으로 반환한다. out x 를 호출하면 출력 x 와 빈 값 ()로 구성된 연산을 반환한다.

모나드 평가자에 이러한 기능을 추가하기 위해서는, 2.5장의 모나드에서 Con a 에 대한 구절에서의 unit a 부분을 아래 내용으로 치환하고

```
out (line (Con a) a) * λ(). unit a
```

Div t u 에 대한 구절에서의 unit (a ÷ b) 부분을 아래 내용으로 치환 하면 된다.

```
out (line (Div t u) (a ÷ b)) * λ(). unit (a ÷ b)
```

또 한 번, 이러한 내용은 비순수 언어에서 필요한 변화에 상응하는 내용이며. 프로그램 작성내용을 간단히 정리하면 2.4 장의 출력 평가자와 동일해진다.
연산의 수행내용들을 역순으로 출력하려면, \* 의 정의를 x++y 에서 y++x 로 바꾸면 된다. 이것은 순수 언어 프로그램에서만 가능한 구현이며, 비순수 언어 프로그램에서 필요로 하는 변화 내용보다 훨씬 간단하다.

아마도 이런 차이가, 순수언어의 구현버젼은 계산이 끝날때까지 아무것도 보여주지 않고, 비순수 언어의 구현버젼은 계산 할때마다 출력을 보여주는 차이라고 생각할 수 도 있다.

하지만, 순수 언어가 지연 평가를 사용하면, 역순의 출력 조차도 계산 과정과 함께 하나 하나 출력 될 수 있다. 또한, 비순수 언어에서 역순 트레이싱 출력을 구현하는 가장 가장 쉬운 구현 방법은 지연 평가 방식를 시뮬레이션하여 구현하는 것이다.

## 3. 모나드 법칙

모나드의 연산은 세가지 법칙을 만족해야 한다.

(i.e. 아래 법칙을 살피기 전에 모나드를 `m * λa. n` 이와 같이 표현했던 것을 기억하자.)

- 왼쪽 항등법칙. (i.e. 연산 m 이 unit 함수 인 경우의 계산) a 값을 계산하고, 결과에 b를 바인딩하고 그 후, n을 계산한다. 그 결과는 값 a 를 변수 b로 대체한 연산 n과 동일해야 한다.

```
unit a * λb. n = n[a/b].
```

- 오른쪽 항등법칙. (i.e. 연산 n 이 unit 함수 인 경우의 계산) m 을 계산하고 그 결과를 a에 바인딩하고 a를 반환한다. 그 결과는 m과 동일해야 한다.

```
m * λa. unit a = m.
```

- 결합법칙. m을 계산하고, 그 결과를 a에 바인딩하고, n을 계산하고, 그 결과를 b에 바인딩하고, o를 계산한다. 이러한 계산에서 괄호의 순서에 상관 없이, 즉 어떤 부분을 먼저 계산 하는가와 상관없이 계산 결과 값이 동일해야한다.

```
m * (λa. n * λb. o) = (m * λa. n) * λb. o.
```

단, 변수 a의 범위는 왼쪽 식에서는 연산 o에 포함되지만, 오른쪽에서는 o에서 벗어나 있으므로, 이 법칙은 a가 o의 free variable 이 아닌 경우에만 유효합니다.

두 개의 왼쪽, 오른쪽 항등 법칙과 결합법칙을 만족하는 이항 연산을 모노이드(Monoid)라고 부른다. 모나드는 모노이드와 달리 오른쪽 연산자에 바인딩 연산이 포함되어 있다.
위의 법칙의 유용성을 증명하기 위해 덧셈이 결합성을 가지는지 증명해보자. 나눗셈이 아닌 덧셈을 기반으로하는 평가자의 변형을 살펴보면.

```
data Term = = Con Int | Add Term Term
eval :: Term -> M Int
eval (Con a) = unit a
eval (Add t u) = eval t * λa. eval u * λb. unit (a + b)
```

(주. 본문에서 unit(a + b) 부분이 unit(a ÷ b) 로 되어 있는데, 아무래도 오타인 것 같아 수정함)
우리는 위에서

```
Add t (Add u v) and Add (Add t u) v
```

이 두가지가 같은 결과로 계산된 다는 것을 보였다.
왼쪽 항을 정리하자면

```
  eval (Add t (Add u v))
= { def’n eval }
  eval t * λa . eval (Add u v ) * λx . unit (a + x )
= { def’n eval }
  eval t * λa . (eval u * λb . eval v * λc . unit (b + c )) * λx . unit (a + x )
= { associative }
  eval t * λa . eval u * λb . eval v * λc . unit (b + c ) * λx . unit (a + x )
= { left unit }
  eval t * λa. eval u * λb. eval v * λc. unit (a + (b + c))
```

오른쪽 항을 정리하면

```
  eval (Add (Add t u) v)
= { as before }
  eval t * λa. eval u * λb. eval v * λc. unit ((a + b) + c)
```

두 결과가 덧셈의 결합법칙을 이용하면 같다는 것을 확인할 수 있다. 이 증명은 단순하지만; 모나드 법칙이 없으면 불가능한 작업이다.
이러한 증명은 예외, 상태, 출력을 포함한 모든 모나드에서 수행될 수 있다. 다만, 이러한 증명은 모나드를 작성한 코드가 위와 같은 경우를 가정한 것이다. 코드가 바뀐다면 증명 방법도 수정되어야 한다. 2.3장 에서 우리는 tick을 호출하도록 평가자 프로그램의 코드를 수정한 바 있다. 이 경우에도 결합법칙은 여전히 보장되며, 다음과 같이 법칙을 사용하여 증명할 수 있다.

```
tick ⋆ λ(). m = m ⋆ λ(). tick
```

위와 같은 증명은 tick 이 m 에 종속된 상태에만 영향을 미친다는 가정하에 유효한 것이다. 2.4장에서는 프로그램에 line 함수의 호출을 추가하는 수정작업을 진행했다. 이 경우 해당 수정작업은 결합법칙을 따르지 않는다. 왜냐하면, 괄호의 위치를 바꾸면 연산을 추적하는 출력이 벼뀌기 때문이다. 다만, 출력 외의 값에 대한 계산은 여전히 같은 값을 생성할 것이다.
다른 예로, 각각의 모나드에 대해 아래의 작업을 정의할 수 있다.

```
map :: (a -> b) -> (M a -> M b)
map f m = m * λa. unit (f a)
join :: M (M a) -> M a
join z = z * λm. m
```

이 map 연산은 단지 함수를 계산한 결과에 적용하는(applicate) 것이다. map f m을 계산하려면, 먼저 m을 계산하고, a에 그 결과를 바인딩한 다음, f a를 반환하면 된다. join 연산은 좀 더 까다롭다. z는 계산 자체를 반환하는 연산이다. join z를 계산하려면, 먼저 z를 계산하고, m 을 그 결과에 바인딩한 다음, 마치 연산 m 처럼 동작시킨다. 이를 통해, join 은 복잡해 보이는 2개의 layer를 가진 계산을 평범한 한개의 layer만을 가진 계산으로 펼칠 수(flatten) 있다. 5.1장에서 보게될 내용 처럼, 리스트 또한 모나드이며, 이 모나드의 map 은 리스트의 각 요소에 함수를 적용하는 것이다. 또한 이 모나드의 join 은 리스트로 감사싸진 리스트들을 concatenate 하는 함수가 된다.
항등함수 `(id x = x)` id 와 함수 합성`((f · g) x = f (g x))` (·)를 사용하면 아래와 같은 법칙들을 만들어낼 수 있다.

```
map id = id
map(f · g) = map f · map g
map f · unit = unit·f
map f · join = join · map (map f)
join · unit = id
join · map unit = id
join · map join = join · join
m * k = join (map k m)
```

각 법칙에 대한 증명은 map 과 join 의 정의, 그리고 모나드의 세가지 법칙을 이용해 간단하게 도출할 수 있다.

대부분의 경우, 모나드는 unit 과 \* 를 이용한 정의 대신에 unit, join, 그리고 map 을 기반으로 정의된다[10,13]. 위에서 살펴본 세가지 모나드 법칙은 위의 여덟 번째까지 법칙 중 앞의 일곱가지 법칙으로 대체될 수 있다. 만약 \* 을 여덟 번째 법칙으로 정의한다면 세가지 모나드 법칙을 모두 다루게 된다. 따라서 이러한 두가지 정의 방법은 동일한 것이다.

## 4.State

배열은 컴퓨팅에서 중요한 역할을 하는데, 이는 현재의 아키텍처와 잘 어울리기 때문이다. 프로그램에는 `x[i]`와 같은 배열의 조회(lookup)나 `x[i]:=v`와 같은 배열 업데이트가 많이 등장한다. 이러한 작업은 배열의 조회가 한개의 인덱스를 사용하는 fetch 명령어로 구현되고, 배열 업데이트가 또한 하나의 인덱스를 사용하는 저장 명령어로 구현되기 때문에 자주 사용된다.

함수형 언어에 배열을 구현하는 것은 쉽다. 배열의 조회를 구현하는 것 역시 간단하다. 반면에, 어떻게 효과적인 배열 업데이트를 구현하는지는 역사가 싶은 문제이다. 모나드는 이 오래된 문제에 대한 새로운 답을 제공한다.
또 다른 오랜 역사를 가진 문제는 "배열 업데이트를 기반으로 프로그램을 만드는 것이 적절하냐?"는 것이다. 많은 알고리즘과 아키텍처들이 배열을 기반으로 개발되는데 너무나 많은 노력들이 기울여져 왔기 때문에, 우리는 이 논쟁의 답을 "그렇다" 라고 가정하며 이 논쟁을 회피하고자 한다.

이전 장에서 모나드가 사용된 방식과, 여기에서 모나드를 사용할 방식에는 중요한 차이가 있다. 이전 장에서는 기존 언어의 기능을 효과적으로 사용하기위해 모나드를 사용하였으나, 이번 장에서는 모나드가 언어의 새로운 기능을 만드는데 어떻게 도움이 될 수 있는지를 보여주고자 한다. 이를 위해, 프로그래밍 언어를 바꿀 필요는 없지만, 새로운 추상데이터 타입이 구현을 통해 제공되어져야 하며, 이는 standard prelude 의 일부로 제공되어질 것이다. (주. standard prelude 는 하스켈 98표준에 의해 정의된 하스켈 표준 라이브러리이다.)

여기서 모나드는 프로그램 내부의 상태를 조작하는 데 사용되지만, 동일한 기술이 외부 상태의 조작, 예를 들어 입출력을 수행하거나 다른 프로그래밍 언어와 커뮤니케이션 하는 등의 작업에 사용될 수 있다. 하스켈의 글래스고 구현 버젼은 입출력을 제공하고, 명령형 언어인 C 와의 커뮤니케이션을 위해 모나드 기반의 디자인을 사용하고 있다. 이 디자인은 표준 하스켈의 1.3 버젼으로 채택되었다.

### 4.1. 배열

Arr 라고 Ix 타입의 인덱스를 가지며, 값을 Val 타입으로 반환하는 배열의 타입을 정의합시다. 주요 연산작업들은 다음과 같은 타입으로 정의될 수 있다.

```
newarray::Val -> Arr,
index::Ix -> Arr -> Val,
update::Ix -> Val -> Arr -> Arr
```

newarray v 를 호출하면, 모든 엔트리의 값을 v로 하는 배열을 반환한다. index i x 의 호출은 배열 x의 인덱스 i에 저장된 값을 반환한다. update i v x 의 호출은 인덱스 i에는 값 v가 있고 나머지는 x와 동일한 배열을 반환한다. 그리고 이러한 작업들이 어떤 방식으로 이루어지는지는 다음의 법칙들을 통해 좀 더 구체화 될 수 있다.

```
index i (newarray v) = v,
index i (update i v x) = v,
index i (update j v x) = index i x , if i ̸= j .
```

이러한 연산들은 실제로는 더 복잡할 수 있다. 예를 들어, 인덱스의 범위를 지정하는 방법등이 필요할 것이다. 하지만 위의 내용들로도 중요한 포인트를 설명해 나갈 수 있을 것이다.

업데이트 작업을 수행하는 효율적인 방법은 지정된 배열의 항목을 덮어 쓰는 것이다. 하지만 순수 함수형 언어에서는 업데이트 작업이 수행되는 시점에, 배열을 참조하는 다른 포인터가 존재하지 않는 경우에만, 이 업데이트가 안전할 수 있다. Schmidt [18]에 따르면 이 속성을 만족하는 배열은 single threaded 라고 부른다.

간단한 명령형 언어의 인터프리터를 만든다고 생각해보자. 이 언어에 대한 추상 문법은 다음과 같은 데이터 타입을 통해 표현될 수 있다.

```
data Term = Var Id | Con Int | Add Term Term
data Comm = Asgn Id Term | Seq Comm Comm | If Term Comm Comm
data Prog = Prog Comm Term
```

여기에서 Id 는 지정되지 않은 종류의 식별자 이다. Term 은 변수, 상수 혹은 두 Term 의 합이다. Comm, 즉 command는 할당 작업, 연속된 두개 command 혹은 조건부 명령이다. 그리고 프로그램은 Comm 과 뒤 따라오는 Term 들로 이루어진다.
프로그램 실행의 현재 상태는 Id 가 인덱스이며, 정수들이 값인 배열로 모델링 될 수 있다.

인터프리터는 다음과 같다.

eval :: Term → State → Int
eval (Var i)x = index i x
eval(Cona)x = a
eval(Addtu)x =evaltx+evalux
exec :: Comm → State → State
exec(Asgnit)x =updatei(evaltx)x
exec(Seqcd)x =execd(execcx)
exec(Iftcd)x =if evaltx =0 then execcx else execdx
elab :: Prog → Int
elab (Prog c t ) = eval t (exec c (newarray 0 ))
